# 真的是最終的區塊鏈壓縮：CoinWitness

2013年8月19日，上午05:53:55 [＃1](https://bitcointalk.org/index.php?topic=277389.msg2961736#msg2961736)

在此消息中，我簡要介紹了一項改進比特幣的可擴展性，靈活性，隱私性和可替代性的提案。這個想法基於最前沿的加密技術，並且需要軟叉來部署 - 所以它不是可以立即實現的東西，但我相信它將是進一步研究的有用領域。

在[SNARKs for C：驗證程序執行簡潔和零知識](http://www.scipr-lab.org/)（以下簡稱SCIP），Eli Ben-Sasson等。描述他們在高效率的非交互式證明方面的工作，這些證據對於用C語言忠實執行的程序沒有任何知識.Eli也在比特幣會議上[提出](http://www.youtube.com/watch?v=YRcPReUpkcU)。

這位簡短的外行人對他們的工作的解釋是，他們構建了一個系統，在這個系統中，有人可以在特殊環境中運行任意程序，然後發布一個非常緊湊且可快速檢查的證據，這將證明任何人1）他們忠實地運行程序（例如，沒有修改或篡改）和2）程序“接受”（例如，退出並返回true;）具有給定的一組公共輸入和（可選地）附加的非公共輸入。因為他們的系統提供計算零知識，所以程序的執行也可以依賴於任何非公共輸入，並且除了程序接受的事實之外，驗證器不會學習它們。

這背後的數學是高度密集的 - 從[驚人的結果開始](http://en.wikipedia.org/wiki/IP_%28complexity%29#PSPACE_is_a_subset_of_IP)從二十多年前開始，所有程序都可以轉換成交互式證明，它們運用多層技術來構建具有實際可以使用的性能的具體系統，而不僅僅是證明程序可能的證據。

我已經提出了一些關於如何在比特幣中使用這種技術的有趣想法，這些技術在[其他地方](https://en.bitcoin.it/wiki/User:Gmaxwell/why_hash_locked)不需要對比特幣本身進行任何改變。但是如果你將技術直接添加到比特幣，一些更有趣的事情就變得可能了。

這個想法的一個明顯的應用是它可以取代[腳本](https://en.bitcoin.it/wiki/Script)在比特幣。您不是嵌入管理區塊鏈內輸出的規則，而是嵌入一個遵循規則的證據。而不是每個人都檢查是否允許花費一筆交易，而是檢查您是否檢查過。

這本身很有意思，因為它可以在不給網絡執行帶來負擔的情況下製作更強大的腳本，但是當現有系統到目前為止大部分未使用時，對腳本的改進並不十分令人興奮。另外，與ECDSA相比，SCIP證明的驗證有點慢（比如說，慢幾百倍），儘管它的擴展性很好，但大多數事務只有一個哈希和ECDSA操作非常簡單。

在這裡，我建議一個非常有趣的方式可以使用此功能。

讓我們假設我的朋友和我就可驗證的脫鏈交易系統的一套規則達成一致。通過“可驗證”，我的意思是，如果其用戶記錄單個硬幣的活動記錄，他們可以向第三方顯示成績單，並且第三方將確信系統行為正確並且將知道誰是硬幣的最終所有者是。

以下是兩個符合該標準的示例係統：

**基於反重放oracle的**
Alice有一個數字硬幣：coin = {Value，Alice's pubkey，硬幣歷史的記錄}，並且想要將它分配給Bob。
Bob告訴Alice Hash（bob的pubkey）= HB。
Alice計算Hash（硬幣）== HC，還有Sign（HB）== SHB。
Alice聯繫了一個值得信賴的反重播神諭，告訴它{HC，SHB}。
oracle返回Sign（{HC，SHB}）當且僅當它從未簽署過以HC開頭的東西時。
Alice將這些信息與硬幣一起傳遞給Bob。鮑勃檢查硬幣的歷史，並確信他有一個沒有花費兩倍的有效硬幣。

這可以繼續下去，將硬幣從一方傳遞到另一方，產生不斷增長的成績單。通過使用M個N個反重放神諭或其他類似的改進，可以簡單地擴展它。這種使用的反重播神諭被認為不會重播，但由於他們只處理哈希，他們對交易一無所知（甚至他們被用於類似貨幣的使用 - 它可能只是所有的時間戳oracle可以告訴）。這樣一個神諭可以在可靠的硬件上，保真保稅，通過賞金輸出來保護，當且僅當你能發布顯示重播的證據時，你可以兌換。

**基於區塊鏈的**
愛麗絲有一個用彩色硬幣代表的比特幣其他一些特定的區塊鏈，也許是一個特定於地理位置的區塊鏈。
Alice以正常方式進行交易，將其傳遞給Bob。
Bob可以通過抓住彩色硬幣路徑上的每個事務以及將它們連接到鏈的SPV片段以及一些額外的區塊鏈標題來形成可驗證的腳本，以顯示交易被充分掩埋。

（我在這裡提供了兩個例子來說明這個想法是完全一般的。任何其他具有可驗證屬性的系統，例如OpenTransactions，涉及所有參與者投票的複雜系統，或者甚至是沒有雙重支出預防的瑣碎系統，都可以如果構造得非常有效，那麼它們的效果最好。）

我稱之為 **CoinWitness** 的想法是這樣的：

您寫下了一個小程序，用於驗證您所選擇的可驗證的脫鏈系統中其中一個成績單的忠實度。該程序要求成績單中的最後一筆交易是特殊的，因為它支付比特幣scrippubkey / p2sh。還必須提供相同的地址作為該計劃的公共輸入。我們將此程序稱為“見證”，因為它將見證成績單並接受當且僅當成績單有效時。

然後使用SCIP證明系統將程序轉換為驗證密鑰。當有人想在脫鏈系統中創建比特幣時，他們會將該硬幣支付給該驗證密鑰的哈希值。然後人們按照自己的意願在脫鏈系統中進行交易。為了確信系統忠實地工作，他們可以重複計算上昂貴的驗證密鑰生成過程，以確認它對應於他們期望的事務規則。

當其中一個硬幣的用戶想要退出系統（壓縮其歷史，移動到另一個系統，花費普通比特幣，或出於任何其他原因）時，他們形成支付比特幣地址的最終交易，並運行證人在SCIP下的成績單並出示證明。他們創建了一個比特幣交易兌換硬幣，在他們的腳本中提供證據（但不是成績單，保留私有），比特幣網絡驗證證明和交易輸出。公眾對中間交易沒有任何了解，改善了可替代性，但與改善可替代性的其他想法不同，這種想法有可能提高比特幣的可擴展性並安全地整合新的和創新的替代交易方法，並將比特幣的零信任性擴​​展到更多類型的交易。

**開放式挑戰** ：
這取決於新的加密技術，這些技術可能存在安全漏洞，並且可能有很大的性能提升空間。使用它需要將驗證軟件添加到比特幣網絡，然後比特幣網絡將特定的證明格式固定下來。

根據我們的標準，SCIP證明驗證很慢。在本文中，他們舉例說明了它們在2.4 GHz主機上的實現，其中對小型公共輸入（CoinWitness的情況）驗證證明（對於80位安全性僅為2576位）需要100ms。這足夠快，考慮到將多個事務壓縮為一個的可能性，如果沒有進一步優化，它實際上可行。

根據我們的標準，SCIP證明結構非常緩慢。在他們的論文中給出了一個執行11001個週期的100指令程序的例子，證明生成需要155分鐘。證明時間基本上與操作次數成線性關係，因此將具有長抄本的硬幣帶回鏈中可能在計算上是禁止的。但是，由於這是在鏈外完成的，因此它至少將工作放在感興趣的一方，而不是將其外部化到整個比特幣用戶群。（並且可能有很大的空間來提高軟件工程的性能，特別是，問題是非常可並行化的）

SCIP密鑰必須具有上述程序執行的操作數量的上限。這導致必須提前提交的最大轉錄本長度。

我相信所有這些問題都是可以克服的，除非這種方法中任何真正令人興奮的加密中斷。

這個CoinWitness的想法是Eli在他的談話中提出的一個不太雄心勃勃的例子 - 在SCIP下有效運行區塊鏈驗證，以生成具有正確性的加密證明的UTXO檢查點。但是，我不建議驗證來自公共區塊鏈的所有交易，而是建議驗證 *私有* 交易的小序列，以避免讓它們公開，並在此過程中提高比特幣的可擴展性，靈活性，隱私性和可替代性。（而且，事實上，對於那些從事SCIP工具的人來說，這個想法實際上可能是顯而易見的，但我希望它會在這裡引起一些爭議）。

來源：https://bitcointalk.org/index.php?topic=277389.msg2961736#msg2961736